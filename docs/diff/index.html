<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Software Design by Example in Roc</title>
<link rel="shortcut icon" type="image/x-icon" href="/book-of-examples/favicon.svg">
<link rel="stylesheet" href="/book-of-examples/bw.css" type="text/css">
<link rel="stylesheet" href="/book-of-examples/site.css" type="text/css">

  </head>
  <body>
    <main>
      <h1>File Diffing</h1>
<p class="author">Written by <a href="https://github.com/hristog">Hristo Georgiev</a>
</p>

<ul>
  <li>The difference between two sequences can be represented as a conversion of a source sequence to a target sequence, via applying a series of insertion, deletion and matching operations, in an element-wise manner.</li>
  <li>Being able to represent the differences between two files is a fundamental feature of version-control systems, whereby it serves to display a commit, the difference between two commits and assist in branch merging operations.</li>
  <li>Context is important when representing differences, and different formats may choose to achieve this via take advantage of context in different ways.</li>
</ul>

<p>Terms defined: ability, diff, dynamic programming, longest common subsequence, memoization, merge, opaque type, platform, version-control system</p>

<ol>
  <li><a href="#section-n1-representation">Representation</a></li>
  <li><a href="#section-n2-longest-common-subsequence-lcs">Longest Common Subsequence (LCS)</a></li>
  <li><a href="#section-n3-colorized-output">Colorized Output</a></li>
  <li><a href="#section-n4-diff-context">Diff Context</a></li>
  <li><a href="#section-n5-unified-format">Unified Format</a></li>
  <li><a href="#section-n6-putting-it-all-together">Putting It All Together</a></li>
  <li><a href="#section-n7-summary">Summary</a></li>
  <li><a href="#section-n8-exercises">Exercises</a></li>
</ol>

<p>In this chapter, we’re going to develop a tool capable of identifying and outputting the differences between two files in a suitable format and presentation. The associated fundamental concepts are integral to version-control systems, because they lie at the very core of operations such as <code class="language-plaintext highlighter-rouge">git diff</code> and <code class="language-plaintext highlighter-rouge">git merge</code>.</p>

<p>Let’s examine the following output, from the UNIX <code class="language-plaintext highlighter-rouge">diff</code> tool, between two toy Roc programs. We can safely ignore the <code class="language-plaintext highlighter-rouge">-u</code> argument for the time being.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> diff -u Hello.roc HelloWorld.roc
<span class="gd">--- Hello.roc &lt;last_modified_timestamp&gt;
</span><span class="gi">+++ HelloWorld.roc &lt;last_modified_timestamp&gt;
</span><span class="p">@@ -1,8 +1,8 @@</span>
<span class="gd">-app "hello"
</span><span class="gi">+app "hello-world"
</span>     packages { pf: "https://github.com/roc-lang/basic-cli/releases/download/0.9.1/y_Ww7a2_ZGjp0ZTt9Y_pNdSqqMRdMLzHMKfdN8LWidk.tar.br" }
     imports [pf.Stdout]
     provides [main] to pf

 main =
<span class="gd">-    Stdout.line "Hello!"
</span><span class="gi">+    Stdout.line "Hello, World!"
</span>
</code></pre></div></div>

<p>Even if you weren’t familiar with the UNIX <code class="language-plaintext highlighter-rouge">diff</code> or similar tools, it’s probably quite obvious what’s going on. The command output tells you that the given files differ in terms of two lines only - namely, the first and last lines, namely the lines defining the app name and outputting a string to the standard output.</p>

<p>By the end of this chapter, you will have developed a Roc tool, which outputs identical information, given the same two input files.</p>

<h2 id="section-n1-representation">Section N.1: Representation</h2>

<p>In the above example, the output was presented intuitively enough, and this enabled us to identify easily what it conveys. For completeness, the listings of the two files are as follows:</p>
<pre><code class="language-roc">$ cat Hello.roc
app "hello"
    packages { pf: "https://github.com/roc-lang/basic-cli/releases/download/0.9.1/y_Ww7a2_ZGjp0ZTt9Y_pNdSqqMRdMLzHMKfdN8LWidk.tar.br" }
    imports [pf.Stdout]
    provides [main] to pf

main =
    Stdout.line "Hello!"

$ cat HelloWorld.roc
app "hello-world"
    packages { pf: "https://github.com/roc-lang/basic-cli/releases/download/0.9.1/y_Ww7a2_ZGjp0ZTt9Y_pNdSqqMRdMLzHMKfdN8LWidk.tar.br" }
    imports [pf.Stdout]
    provides [main] to pf

main =
    Stdout.line "Hello, World!"

</code></pre>

<p>The difference between same two files - without any modifications to the files themselves - could be represented alternatively like so:</p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> uglydiff Hello.roc HelloWorld.roc
<span class="gd">--- Hello.roc &lt;last_modified_timestamp&gt;
</span><span class="gi">+++ HelloWorld.roc &lt;last_modified_timestamp&gt;
</span><span class="p">@@ -1,8 +1,8 @@</span>
<span class="gi">+app "hello-world"
</span><span class="gd">-app "hello"
</span>     packages { pf: "https://github.com/roc-lang/basic-cli/releases/download/0.9.1/y_Ww7a2_ZGjp0ZTt9Y_pNdSqqMRdMLzHMKfdN8LWidk.tar.br" }
     imports [pf.Stdout]
     provides [main] to pf

 main =
<span class="gi">+    Stdout.line "Hello, World!"
</span><span class="gd">-    Stdout.line "Hello!"
</span>
</code></pre></div></div>

<p>And even like so:</p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> uglierdiff Hello.roc HelloWorld.roc
<span class="gd">--- Hello.roc &lt;last_modified_timestamp&gt;
</span><span class="gi">+++ HelloWorld.roc &lt;last_modified_timestamp&gt;
</span><span class="p">@@ -1,8 +1,8 @@</span>
<span class="gd">-app "hello"
-    packages { pf: "https://github.com/roc-lang/basic-cli/releases/download/0.9.1/y_Ww7a2_ZGjp0ZTt9Y_pNdSqqMRdMLzHMKfdN8LWidk.tar.br" }
-    imports [pf.Stdout]
-    provides [main] to pf
-
-main =
-    Stdout.line "Hello!"
-
</span><span class="gi">+app "hello-world"
+    packages { pf: "https://github.com/roc-lang/basic-cli/releases/download/0.9.1/y_Ww7a2_ZGjp0ZTt9Y_pNdSqqMRdMLzHMKfdN8LWidk.tar.br" }
+    imports [pf.Stdout]
+    provides [main] to pf
+
+main =
+    Stdout.line "Hello, World!"
+
</span></code></pre></div></div>

<p>Now, what makes the output from <code class="language-plaintext highlighter-rouge">diff</code> much more useful and immediately intuitive than its counterparts from the hypothetical <code class="language-plaintext highlighter-rouge">uglydiff</code> and <code class="language-plaintext highlighter-rouge">uglierdiff</code> tools? It succinctly presents the actual differences and doesn’t distract away from those differences. In the hypothetical, non-intuitive cases, we see that - despite those being still valid representations of differences - the degree of usefulness isn’t as high as it could be. In the first case, instead of the more natural flow “from this file, we arrive at that file”, we are presented with a “we introduce this, whilst originally we had that”, which awkwardly interrupts the reader’s flow. In the latter case, no useful intuition regarding the actual differences is conveyed, because any two distinct files could be crudely viewed as differing in their corresponding line sequences atomically. In other words, we could replace all lines from the first file with all lines from the second file and this, effectively, constitutes the difference between them.</p>

<h2 id="section-n2-longest-common-subsequence-lcs">Section N.2: Longest Common Subsequence (LCS)</h2>

<p>In this section, we’ll get acquainted with a data structure which will enable us to express all possible paths that correspond to constructing a target file from a source file, based on a number of insertion, deletion and matching operations. Then we’ll build intuition, regarding how we could heuristically traverse said data structure, in order to be able to choose a single path, which will be the path ultimately presented as the one, succinctly and intuitively representing the difference between the two files.</p>

<p>This automatically means that we wouldn’t want to be considering matching blocks of lines from the two files as differences (as it was unfortunately the case with the hypothetical <code class="language-plaintext highlighter-rouge">uglierdiff</code> tool). This is where an important observation lies - one key ingredient we need is a method for identifying the longest possible stretches of matching sequences between the given files. The other key ingredient is that, if we’re to view a diff between two files as a means for transforming one file into another one (even though this may not be be the actual desired outcome at all, you’ll see that this is a very useful conceptual representation), then the first one could be viewed as a “source”, and the second one - as a “target”. Correspondingly, the chain of operations transforming our source into the target will be the ultimate diff output. Therefore, in addition to identifying long stretches of matching lines between the two files, we’ll also be interested in thinking in terms of removals of lines from the source file and preservations (or insertions, with respect to the former) of lines that are already present in the target file, but not in the former. Naturally, we won’t be performing any modifications to stretches of matching elements between the two sequences. Those are the parts of our output which we would ideally like to keep out of focus as much as possible. They could be useful to provide context, but they shouldn’t be at the center of attention.</p>

<p>This particular representation is also referred to as <em>unified format</em>, in the context of the GNU <code class="language-plaintext highlighter-rouge">diff</code> tool, and that was the relevance of the <code class="language-plaintext highlighter-rouge">-u</code> command-line argument  in the opening paragraph (alternatively accessible via the <code class="language-plaintext highlighter-rouge">--unified</code> flag). Some alternative representations, which we won’t be discussing in this chapter are the <em>normal format</em> (<code class="language-plaintext highlighter-rouge">--normal</code>) and <em>context format</em> (<code class="language-plaintext highlighter-rouge">-c</code> or <code class="language-plaintext highlighter-rouge">--context</code>). They’re closely related and are possible to be derived - with relatively minor modifications - using the approaches which we’ll get acquainted with in this chapter. Naturally, for further details and even more possible representations, you’re welcome to refer to GNU <code class="language-plaintext highlighter-rouge">diff</code>’s <code class="language-plaintext highlighter-rouge">man</code> pages.</p>

<p>Let’s step back a bit and try to think in what domains we’d expect to see applications of the kind of algorithms are relevant to our use case. Given two or more sequences of comparable-for-equality items, it is of interest to identify the longest possible subsequences of items which are equal between the sequences under consideration.</p>

<ul>
  <li>For instance, in bioinformatics and molecular biology, DNA sequences can be represented via the symbols A, C, G and T which correspond to the four nucleobases, associated with DNA molecules, namely adenine, cytosine, guanine and thymine. One possible use-case is comparison between DNA sequences for the purpose of capturing some notion of similarity, for instance, with respect to a new DNA sequence. Then, one form of a similarity metric is finding the longest common subsequence between the input sequences.</li>
  <li>In computational linguistics, two strings may be compared for similarity in multiple ways, and the longest common subsequence is one way of solving the approximate string matching problem.</li>
  <li>In terminal-based text editor implementations, screen redisplay may be viewed as the minimum length sequence of characters that need to be changed in order for the screen update to be performed, in accordance to file changes. The longest common subsequence is relevant in that context, because it delineates the parts of the screen that don’t need updating.</li>
  <li>Identifying differences between files, which is the main topic of this chapter.</li>
</ul>

<p>For simplicity and ease of visualization, let’s consider pairs of strings of characters, which are equivalent - relative to each other - to the source-code example from the beginning section. Two arbitrary string sequences - where each character is a line in a file - which meet these needs are the following ones:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>source.txt
A
B
C
D
E
F
G
H
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>target.txt
I
B
C
D
E
F
J
H
</code></pre></div></div>

<p>The corresponding most intuitive diff path is as follows:</p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> diff -u source.txt target.txt
<span class="gd">--- source.txt &lt;last_modified_timestamp&gt;
</span><span class="gi">+++ target.txt &lt;last_modified_timestamp&gt;
</span><span class="p">@@ -1,8 +1,8 @@</span>
<span class="p">@@ -1,8 +1,8 @@</span>
<span class="gd">-A
</span><span class="gi">+I
</span> B
 C
 D
 E
 F
<span class="gd">-G
</span><span class="gi">+J
</span> H
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># TODO: Ensure consistent terminology, in terms of the input lists/strings/arrays/sequences. It may be confusing, if referred to as sequences.
</code></pre></div></div>

<p>As discussed, we’ll first focus on finding a way to conveniently identify and represent all possible paths from the source sequence to the target sequence. Only then we’ll be able to pick the path which conveys the difference in a generally intuitive way, given the aforementioned presentation constraints we’re interested to enforce.</p>

<p>We’ll resort to a class of algorithms for solving what’s referred to as the <em>Longest Common Subsequence</em> (LCS) problem. One of the most common problem-solving approaches is breaking a problem into equivalent but smaller sub-problems. This very intuition is also applicable in our case. In order to identify the longest common subsequence between any two lists of elements, we observe that we would start with an empty common subsequence, and then seek to incrementally find matching elements in each list, in order to identify longer and longer subsequences until we’ve exhausted at least one of the lists. There exist no general shortcuts which would allow us to generally identify the longest common subsequence without iterating over the contents of both lists first. That’s why the problem of identifying a longest common subsequence gets conveniently and intuitively broken down to be defined recursively in terms of the solutions at different iteration steps. The longest common subsequence as of the current step <em>t</em> is defined to be equal to the longest common subsequence as of step <em>t-1</em>, in conjunction with the best possible solution at step <em>t</em>, among the following options:</p>
<ul>
  <li>the two current elements in each list are already a match, or</li>
  <li>removing the current element from the source list results in a match, or</li>
  <li>inserting the next element from the target list results in a match.</li>
</ul>

<p>Let’s see how we might implement a Roc function, which will give us an arbitrary longest subsequence, that is common to two lists of elements:</p>
<pre><code class="language-roc">lcs : List a, List a -&gt; List a where a implements Eq
lcs = \xxs, yys -&gt;
    when (xxs, yys) is
        ([], _) -&gt; []
        (_, []) -&gt; []
        _ -&gt;
            { before: x, others: xs } = List.split xxs 1
            { before: y, others: ys } = List.split yys 1
            if x == y then
                List.concat x (lcs xs ys)
            else
                longest (lcs xxs ys) (lcs xs yys)

longest = \xs, ys -&gt;
    if List.len xs &gt; List.len ys then xs else ys
</code></pre>

<p>Before we discuss the concrete Roc features that we utilize in this excerpt, let’s briefly go over the core idea behind the <code class="language-plaintext highlighter-rouge">lcs</code> function. It takes two lists and recursively calls itself in order to return an arbitrary longest common subsequence, with respect to the input lists. The recursive calls follow the logic discussed above, namely they contain solutions to sub-problems, which are then concatenated together to form a valid solution to the main problem. Concretely, with respect to any two lists that are being considered as part of the execution flow, we check whether either of them is empty. If yes, we know that we’ve traversed as much as we could along that particular list and that’s our cue to stop our iteration. If they’re both non-empty, however, then we inspect the elements at their very beginning. If the elements are equal, then we take a note of the element value and we add it as an element belonging to the longest common subsequence solution. Then, we analogously inspect the remainders of the lists. If the elements aren’t equal, we branch off recursively to identify from which list we should skip the non-matching element, in order to ultimately arrive at a longest possible solution. For this purpose, we also employ an auxiliary function <code class="language-plaintext highlighter-rouge">longest</code>, which ensures that we pick the longest branch, with respect to any solution to a sub-problem.</p>

<p>In the <code class="language-plaintext highlighter-rouge">lcs</code> function, we take advantage of multiple Roc features. First, the type parameter <code class="language-plaintext highlighter-rouge">a</code> indicates that this function works with respect to lists of an arbitrary type, as long as that’s the type associated with both lists. The constraint <code class="language-plaintext highlighter-rouge">where a implements Eq</code> signifies that we’re making use of the abilities feature. In this case, we refer to the built-in <code class="language-plaintext highlighter-rouge">Eq</code> ability which requires that the corresponding type implements this ability, in order for us to be able to compare any two associated values for equality. In the function body, we perform pattern matching on both of the input lists, via packing them in a tuple. This allows us to define our stopping condition - we check if either list is empty, and if yes - we return an empty list. This is handy, because it allows us to recursively call the same function to traverse the lists and extract an arbitrary longest common subsequence at any execution step. We also note the employment of the standard library <code class="language-plaintext highlighter-rouge">List.split</code> function, which takes an arbitrary list and an index, and splits the list at that index, returning a record consisting of two fields, namely <code class="language-plaintext highlighter-rouge">before</code> and <code class="language-plaintext highlighter-rouge">others</code> lists. The former contains all the elements preceding the input index, at which we want to split our original list, and the latter - all elements that follow afterwards. Please, note that the function doesn’t trim away any elements, and that at least one of the returned record fields may be an empty list. In our case, however, we don’t need to check whether or not the <code class="language-plaintext highlighter-rouge">before</code> list is empty, because that was already taken care of by the base cases in our preceding pattern matching expressions.</p>

<p>Please, note that - as discussed above - as of step <em>t</em>, multiple paths may correspond to the longest solution. This is expected, because in this first stage, we are only interested in finding <em>all</em> paths, and not necessarily picking a “best” path just yet.</p>

<p>You’ll also notice that each complete path (that is, a solution leading from a source list to a target list) corresponds to a unique diff presentation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## TODO:
- A narrative transition and a couple of equations which briefly introduce how the dynamic programming table is built.
Define a subsequence to be any output string obtained by deleting zero or more symbols from an input string.
The Longest Common Subsequence (LCS) is a subsequence of maximum length common to two or more strings.

S[i, j] = ...
where S[i, j] corresponds to the solution as of current step _t_ being at index _i_ in the first list and index _j_ in the second one, i.e., X_i and Y_j, respectively.

First property:
LCS(X ^ c, Y ^ c) = LCS(X, Y) ^ c, for all symbols c
e.g.,
LCS("ACGGT", "TCGT") = LCS("ACGG", "TCG") ^ "T" = LCS("ACG", "TC") ^ "GT"

Second property:
For all p and q, such that p != q, i.e., they are distinct symbols,
LCS(X ^ p, Y ^ q) is in the set LCS(X ^ p, Y) &lt;set_union&gt; LCS (X, Y ^ q) and not only this but it is also one of the maximal-length strings in that set.

For example,
LCS("ACGGTA", "TCGTC") is the longest common string among the longest common substrings which belong to the set union of LCS("ACGGTA", "TCGT") and LCS("ACGGT", "TCGT").

LCS(X_i, Y_j) =
ε, if i = 0 or j = 0
LCS(X_{i-1}, Y_{j-1})^x_i, if i &gt; 0 and j &gt; 0 and x_i = y_j
LCS(max(X_{i-1}, Y_j)^x_i, LCS(X_{i-1}, Y_j)), if i &gt; 0 and j &gt; 0 and x_i != y_j

Wiki excerpt:
To find the LCS of }} and }}, compare }} and }}. If they are equal, then the sequence }(X_,Y_)}}(X_,Y_)} is extended by that element, }}. If they are not equal, then the longest among the two sequences, }(X_,Y_)}}(X_,Y_)}, and }(X_,Y_)}}(X_,Y_)}, is retained. (If they are the same length, but not identical, then both are retained.) The base case, when either }} or }} is empty, is the empty string, .

TODO: Introduce and discuss the significance of ε.

LCS("ABCDEFGH", "IBCDEFJH") = LCS("ABCDEFG", "IBCDEFJ") ^ "H
LCS("ABCDEFG", "IBCDEFJ") is a maximal-length string in the set LCS("ABCDEFG", "IBCDEF") &lt;set_union&gt; LCS("ABCDEF", "IBCDEFJ")


LCS("ε", c) = 0 for all symbols `c`
LCS(c, "ε") = 0 for all symbols `c`

LCS("ε", "ε") = 0
LCS("εA", "ε" ^ S) = 0 for `S` in {"", "I", "IB", "IBC", "IBCD", "IBCDE", "IBCDEF", "IBCDEFJ", "IBCDEFJH"}
LCS("ε" ^ S, "εI") = 0 for `S` in {"", "A", "AB", "ABC", "ABCD", "ABCDE", "ABCDEF", "ABCDEFG", "ABCDEFGH"}
LCS("εAB", "εIB" ^ S) = 1 for `S` in {"", "C", "CD", "CDE", "CDEF", "CDEFJ", "CDEFJH"} because i, j-1 and i-1, j ...
LCS("εAB" ^ S, "εIB") = 1 for `S` in {"", "C", "CD", "CDE", "CDEF", "CDEFG", "CDEFGH"} ...
LCS("εABC", "εIBC" ^ S) = 2 for `S` in {"", "D", "DE", "DEF", "DEFJ", "DEFJH"} ...
LCS("εABC" ^ S, "εIBC") = 2 for `S` in {"", "D", "DE", "DEF", "DEFG", "DEFGH"} ...
...
LCS("εABCDEFGH", "εIBCDEFJH") = 6

</code></pre></div></div>

<p>Conceptually, we’ve already built the data structure which will allow us to recover any path or a sub-path, corresponding to a full or partial solution to our problem of identifying differences between two lists of elements.</p>

<p>The conventional way to build the data structure is in a tabular form. We arbitrarily set the row headers to correspond to the elements of the source list and the column headers - to those of the target one.</p>

<p>The complete table is as follows:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">I</th>
      <th style="text-align: center">B</th>
      <th style="text-align: center">C</th>
      <th style="text-align: center">D</th>
      <th style="text-align: center">E</th>
      <th style="text-align: center">F</th>
      <th style="text-align: center">J</th>
      <th style="text-align: center">H</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">ε</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">A</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">B</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">C</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">D</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">E</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">G</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">H</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">6</td>
    </tr>
  </tbody>
</table>

<p>As you can see, we conventionally take a note of the length of the longest common subsequence found as of a given iteration step. This isn’t really fundamental to our difference representation problem, but will come in handy at the stage when we’ll need to heuristically decide which path to present as the ultimate solution. The other bit of information that we take a note of is somehow more relevant, namely the operation which we perform at a given iteration step, based on the equality between the current list elements <code class="language-plaintext highlighter-rouge">X</code><sub><code class="language-plaintext highlighter-rouge">i</code></sub> and <code class="language-plaintext highlighter-rouge">Y</code><sub><code class="language-plaintext highlighter-rouge">j</code></sub> as of that iteration step.</p>

<p>Once we’ve built the table, it becomes obvious that all solutions correspond to movements along the table cells in one of three possible directions at a time: right, down or diagonally right-down. The complete paths - which are effectively possible solutions to the diff problem - correspond to moves from the top left cell to the bottom right cell.</p>

<p>The most intuitive path and solution discussed before is the following one:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">I</th>
      <th style="text-align: center">B</th>
      <th style="text-align: center">C</th>
      <th style="text-align: center">D</th>
      <th style="text-align: center">E</th>
      <th style="text-align: center">F</th>
      <th style="text-align: center">J</th>
      <th style="text-align: center">H</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">ε</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">A</td>
      <td style="text-align: center">↑0</td>
      <td style="text-align: center">←0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">B</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">↖1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">C</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">↖2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">D</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">↖3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">E</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">↖4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">↖5</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">G</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">↑5</td>
      <td style="text-align: center">←5</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">H</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">↖6</td>
    </tr>
  </tbody>
</table>

<p>Correspondingly, the least intuitive solution corresponds to this path:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">I</th>
      <th style="text-align: center">B</th>
      <th style="text-align: center">C</th>
      <th style="text-align: center">D</th>
      <th style="text-align: center">E</th>
      <th style="text-align: center">F</th>
      <th style="text-align: center">J</th>
      <th style="text-align: center">H</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">ε</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">A</td>
      <td style="text-align: center">↑0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">B</td>
      <td style="text-align: center">↑0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">C</td>
      <td style="text-align: center">↑0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">D</td>
      <td style="text-align: center">↑0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">E</td>
      <td style="text-align: center">↑0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">↑0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">G</td>
      <td style="text-align: center">↑0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">H</td>
      <td style="text-align: center">↑0</td>
      <td style="text-align: center">←0</td>
      <td style="text-align: center">←1</td>
      <td style="text-align: center">←2</td>
      <td style="text-align: center">←3</td>
      <td style="text-align: center">←4</td>
      <td style="text-align: center">←5</td>
      <td style="text-align: center">←5</td>
      <td style="text-align: center">←6</td>
    </tr>
  </tbody>
</table>

<p>This visual representation enables us to build further intuition regarding the desired solution form. Heuristically speaking, we observe that favorable solutions will involve, wherever applicable, long stretches of deletions from the source list and long stretches of insertions from the target list, interspersed with long stretches of matching (i.e., common) subsequences.</p>

<p>Now let’s try to build the data structure in Roc.</p>

<pre><code class="language-roc">Table : Dict (U64, U64) U64

buildTable : List a, List a -&gt; Table where a implements Eq
buildTable = \x, y -&gt;
    List.walkWithIndex
        x
        (Dict.empty {})
        (\tableX, xi, i -&gt;
            List.walkWithIndex
                y
                tableX
                (\tableY, yj, j -&gt;
                    curr =
                        if i == 0 || j == 0 then
                            0
                        else if xi == yj then
                            prevMatch = Dict.get tableY (i - 1, j - 1) |&gt; Result.withDefault 0
                            prevMatch + 1
                        else
                            prevInsert = Dict.get tableY (i, j - 1) |&gt; Result.withDefault 0
                            prevDelete = Dict.get tableY (i - 1, j) |&gt; Result.withDefault 0
                            Num.max prevInsert prevDelete

                    Dict.insert tableY (i, j) curr
                )
        )
</code></pre>

<p>Our <code class="language-plaintext highlighter-rouge">buildTable</code> function takes two arbitrary lists of the same type and builds an LCS table, which is returned to the caller. The type itself is guaranteed to implement the built-in <code class="language-plaintext highlighter-rouge">Eq</code> ability, and the table is of type <code class="language-plaintext highlighter-rouge">Dict (U64, U64) U64</code>. The latter corresponds to a dictionary whose keys are tuples of <code class="language-plaintext highlighter-rouge">(i, j)</code> table indices, both of type <code class="language-plaintext highlighter-rouge">U64</code> and the value corresponds to the length of the longest common subsequence associated with the sublists, of the input lists, ending at indices <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>. We utilize the standard library <code class="language-plaintext highlighter-rouge">List.walkWithIndex</code> function to iterate row by row, and element by element, within each row.
<code class="language-plaintext highlighter-rouge">Result.withDefault 0</code> is logically never expected to become effective, because the indices <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> are iterated over in order and all previous entries will have been present. Further, the base cases where the boundaries of the table are delineated are already handled via <code class="language-plaintext highlighter-rouge">if i == 0 || j == 0 then 0</code>. Alternatively, we could’ve pattern matched for each of the possible previous-step operations - namely, match, insertion or deletion - and <code class="language-plaintext highlighter-rouge">crash</code>ed with an indicative enough message, if we ever got an error of type <code class="language-plaintext highlighter-rouge">KeyNotFound</code>, because something fundamental had gone wrong at that stage, and wasn’t possible to be caught via our test suite.</p>

<p>Our next step is to actually traverse the data structure we’ve just built, and find our way through it via what we deem heuristically to be the best path, in order to ultimately arrive at an intuitive solution.</p>

<pre><code class="language-roc">beginningMark = "ε"

diff : List Str, List Str -&gt; List Str
diff = \x, y -&gt;
    xPrim = List.prepend x beginningMark
    yPrim = List.prepend y beginningMark
</code></pre>

<p>We begin by prepending the sentinel value <code class="language-plaintext highlighter-rouge">ε</code> to our lists, so that we can define the base-cases in our dynamic programming solution. We also define a helper function, <code class="language-plaintext highlighter-rouge">diffHelp</code>, which takes as inputs the already-built table, the updated lists, and the 0-based indices, corresponding to the last element in each list. In other words, we start at the bottom right of our table and proceed to complete our traversal at top left cell. We explicitly pass the current indices to <code class="language-plaintext highlighter-rouge">diffHelp</code> because we would like to be able to call it recursively, and only stop once we’ve completed the traversal of our LCS table.</p>

<pre><code class="language-roc">diff : List Str, List Str -&gt; List Str
diff = \x, y -&gt;
    xPrim = List.prepend x beginningMark
    yPrim = List.prepend y beginningMark
    diffHelp (buildTable xPrim yPrim) xPrim yPrim (List.len x) (List.len y)

diffHelp : Table, List Str, List Str, U64, U64 -&gt; List Str
diffHelp = \lcs, x, y, i, j -&gt;
    (xi, up) =
        if i &gt; 0 then
            (
                (List.get x i |&gt; Result.withDefault beginningMark),
                (Dict.get lcs (i - 1, j) |&gt; Result.withDefault 0),
            )
        else
            (beginningMark, 0)

    (yj, left) =
        if j &gt; 0 then
            (
                (List.get y j |&gt; Result.withDefault beginningMark),
                (Dict.get lcs (i, j - 1) |&gt; Result.withDefault 0),
            )
        else
            (beginningMark, 0)

    if i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; xi == yj then
        List.append (diffHelp lcs x y (i - 1) (j - 1)) "  $(xi)"
    else if j &gt; 0 &amp;&amp; (i == 0 || left &gt;= up) then
        List.append (diffHelp lcs x y i (j - 1)) "+ $(yj)"
    else if i &gt; 0 &amp;&amp; (j == 0 || left &lt; up) then
        List.append (diffHelp lcs x y (i - 1) j) "- $(xi)"
    else
        []
</code></pre>
<p>We store the current element values of the lists in <code class="language-plaintext highlighter-rouge">xi</code> and <code class="language-plaintext highlighter-rouge">yj</code> respectively; <code class="language-plaintext highlighter-rouge">up</code> and <code class="language-plaintext highlighter-rouge">left</code> are the LCS lengths associated with the cells above and to tte left of the current cell. If the current elements are equal, we proceed diagonally in a top-left direction, because the reverse operation, i.e., moving in a bottom-right direction corresponds to matching the current elements and effectively “skipping” them, without performing either insertion or deletion. If however, the LCS length in the cell to the left is greater than or equal to the cell above, then we proceed with our traversal to the left. Otherwise, we move up. This is because we’ve established that intuitively we would like to arrange the diff operations in such way, so that deletion operations from the source list come before the insertion operations from the target list. And when we’re traversing the table backwards, we give priority to the latter, when the correponding LCS lengths are equal.</p>

<p>Additionally, upon each conditional branch, we check the boundary condition of whether we’re either at the <code class="language-plaintext highlighter-rouge">0</code>th row or <code class="language-plaintext highlighter-rouge">0</code>th column.</p>

<h2 id="section-n3-colorized-output">Section N.3: Colorized Output</h2>

<p>Now, when we think about representation of differences between files, we usually have some expectation regarding color-coding as well, in order to better highlight what the associated operations which constitute the diff are. It is important to note that the GNU <code class="language-plaintext highlighter-rouge">diff</code> tool doesn’t provide color-coding per se, but it instead formats the output in a standardized way, so that the associated representation could optionally undergo subsequent syntax highlighting via other tools, editors or IDEs, as applicable.</p>

<p>In this section we’ll briefly introduce some rudimentary color-coding to our diff output, and in the following one we’ll generalize our post-processing logic, which will enable us to perform color-coding in a bit more elegant manner. It’ll also enable us to perform other post-processing steps, for the purpose of increasing the degree of interpretability of the output.</p>

<p>We’ll follow <code class="language-plaintext highlighter-rouge">git</code>’s diff representation, namely colorizing lines corresponding to insertions in green, and those corresponding to deletions - in red. Please, note that this doesn’t take any special consideration of terminal emulator themes, nor any other external context.</p>

<p>Practically speaking, terminal output colorization is achieved via what are referred to as ANSI escape codes. We prepend a sequence of characters to the line to denote that we want a foreground color to be applied to all characters on that line. In order to preserve the formatting on lines where the same diff operation doesn’t apply, we append an escape code for resetting the formatting at the end of each colorized line, namely <code class="language-plaintext highlighter-rouge">"\u(001b)[0m"</code>. The escape codes for green and red foreground colors are <code class="language-plaintext highlighter-rouge">"\u(001b)[6;33;32m"</code> and <code class="language-plaintext highlighter-rouge">"\u(001b)[6;33;31m"</code>, respectively.</p>

<p>For further details, please, refer to the “Colors” section of Wikipedia’s “ANSI escape code” page<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. Now let’s implement a simple text colorization function.</p>

<pre><code class="language-roc">green = "\u(001b)[6;33;32m"
red = "\u(001b)[6;33;31m"
resetFormatting = "\u(001b)[0m"

Color : [GreenFg, RedFg]
colorizeText : Color, Str -&gt; Str
colorizeText = \color, input -&gt;
    when color is
        GreenFg -&gt; "$(green)$(input)$(resetFormatting)"
        RedFg -&gt; "$(red)$(input)$(resetFormatting)"
</code></pre>

<p>And just like this, we’re able to arbitrarily apply colors to text. Our diff operations are color-coded - insertions in green and deletions in red. Please, note that the color choices are arbitrary in this case. It would be equally seamless to colorize the background of each line, i.e., achieve some sort of highlighting, via employing <code class="language-plaintext highlighter-rouge">"\u(001b)[6;33;42m"</code> and <code class="language-plaintext highlighter-rouge">"\u(001b)[6;33;41m"</code> for green and red, correspondingly. This is because background colors span over the 40 to 48 escape-code range.</p>

<pre><code class="language-roc">    else if j &gt; 0 &amp;&amp; (i == 0 || left &gt;= up) then
        List.append (diffHelp lcs x y i (j - 1)) (colorizeText GreenFg "+ $(yj)")
    else if i &gt; 0 &amp;&amp; (j == 0 || left &lt; up) then
        List.append (diffHelp lcs x y (i - 1) j) (colorizeText RedFg "- $(xi)")
</code></pre>

<p>By putting our <code class="language-plaintext highlighter-rouge">colorizeText</code> function to use in our <code class="language-plaintext highlighter-rouge">diffHelp</code> function, we’re now able to associate our colorization preferences to the insertion and deletion operations.</p>

<h2 id="section-n4-diff-context">Section N.4: Diff Context</h2>

<p>So far, our diff output serves the job as advertized. However, if we consider real-world examples for file changes, it is not at all unlikely that a change in a file may involve a handful of lines, whilst the total file size in terms of number of lines may be in the hundreds or even thousands.</p>

<p>This is actually a tricky class of cases that our tool, at the current stage of its development, is likely to not be able to handle well at all. We might have to manually scroll through the output or filter by diff marks, in order to identify where <em>exactly</em> the differences are. This suggests that most of the context in such cases isn’t really useful, if we would be filtering it out eventually. What could we do to improve our tool, with respect to this? We might want to introduce the notion of context, in terms of line adjacency, and only display up to a certain number of lines away from each contiguous set of lines associated with diff marks. This is essentially how the GNU <code class="language-plaintext highlighter-rouge">diff</code> tool works as well, in some of its modes.</p>

<p>First, let’s adapt our implementation, so that it can carry some metadata alongside the actual content that’s being compared. Naturally, the associated number with a given line in a file constitutes a handy bit of metadata that we wouldn’t mind having around.</p>

<pre><code class="language-roc">Line := { lineNumber : U64, content : Str } implements [Eq { isEq: areLinesEqual }]
DiffOp : [Insertion, Deletion, Match]
DiffLine : { op : DiffOp, source : Line, target : Line }
Diff : List DiffLine

areLinesEqual : Line, Line -&gt; Bool
areLinesEqual = \@Line { content: x }, @Line { content: y } -&gt; x == y

beginningMark = @Line { lineNumber: 0, content: "ε" }

toLines : List Str -&gt; List Line
toLines = \list -&gt;
    List.mapWithIndex list \elem, idx -&gt; @Line {
            lineNumber: idx + 1,
            content: elem,
        }
</code></pre>

<p>We define a <code class="language-plaintext highlighter-rouge">Diff</code> to be a list of <code class="language-plaintext highlighter-rouge">DiffLines</code>, with each of the latter being a record consisting of a <code class="language-plaintext highlighter-rouge">DiffOp</code> and the source and target <code class="language-plaintext highlighter-rouge">Line</code>s, with respect to which the diff op is applied. These definitions also enable us to generalize our <code class="language-plaintext highlighter-rouge">diffHelp</code> function to <code class="language-plaintext highlighter-rouge">Line</code>s instead of just <code class="language-plaintext highlighter-rouge">Str</code>s:</p>
<pre><code class="language-roc">diff : List Str, List Str -&gt; Diff
...
diffHelp : Table, List Line, List Line, U64, U64 -&gt; Diff
...
    if i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; xi == yj then
        List.append (diffHelp lcs x y (i - 1) (j - 1)) { op: Match, source: xi, target: yj }
    else if j &gt; 0 &amp;&amp; (i == 0 || left &gt;= up) then
        List.append (diffHelp lcs x y i (j - 1)) { op: Insertion, source: xi, target: yj }
    else if i &gt; 0 &amp;&amp; (j == 0 || left &lt; up) then
        List.append (diffHelp lcs x y (i - 1) j) { op: Deletion, source: xi, target: yj }

</code></pre>

<p>Since our <code class="language-plaintext highlighter-rouge">diff</code> method is a bit more abstract in that it returns a <code class="language-plaintext highlighter-rouge">Diff</code>, we need a means for actually converting the latter to a list of strings which could then be readily output as necessary.</p>

<pre><code class="language-roc">diffFormat : List Str, List Str -&gt; List Str
diffFormat = \x, y -&gt;
    diff x y |&gt; formatDiff

formatDiff : Diff -&gt; List Str
</code></pre>

<p>Thus, we defer text colorizing to the <code class="language-plaintext highlighter-rouge">formatDiff</code> function where, based on the value of <code class="language-plaintext highlighter-rouge">DiffOp</code>, colors are applied to the <code class="language-plaintext highlighter-rouge">content</code> value of a <code class="language-plaintext highlighter-rouge">Line</code>. Further, <code class="language-plaintext highlighter-rouge">diffFormat</code> becomes our highest-level function, in terms of abstraction. Basically, it computes the diff and then formats it accordingly, for the purpose of readability. It takes two list of strings as input and returns another list of strings, corresponding to the diff of the former. The distinction between <code class="language-plaintext highlighter-rouge">formatDiff</code> and <code class="language-plaintext highlighter-rouge">diffFormat</code> is that the former is an auxiliary function which applies formatting to a diff, and the latter is our end-to-end function which computes a diff and then applies formatting.</p>

<p>The body of the <code class="language-plaintext highlighter-rouge">formatDiff</code> function is as follows:</p>
<pre><code class="language-roc">formatDiff = \diffResult -&gt;
    List.map diffResult \elem -&gt;
        (_, source) = unpackLine elem.source
        (_, target) = unpackLine elem.target

        when elem.op is
            Match -&gt; "  $(source)"
            Insertion -&gt; colorizeText GreenFg "+ $(target)"
            Deletion -&gt; colorizeText RedFg "- $(source)"

unpackLine : Line -&gt; (U64, Str)
unpackLine = \@Line { lineNumber, content } -&gt; (lineNumber, content)
</code></pre>

<p>Going back to the primary direction of this section, we observe that the <code class="language-plaintext highlighter-rouge">toLines</code> function enables us to annotate an entire file with the corresponding line numbers as metadata. The purpose of the latter will be two-fold - enabling us to maintain a sufficient context size, ideally parametrizable; and also serving as an indicator of where in the corresponding files this context occurs. As you saw in the intro section, it is precisely this type of context which <code class="language-plaintext highlighter-rouge">diff -u</code> includes in its output.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>man diff
DIFF<span class="o">(</span>1<span class="o">)</span>

NAME
       diff - compare files line by line

SYNOPSIS
       diff <span class="o">[</span>OPTION]... FILES

DESCRIPTION
       Compare FILES line by line.
...
       <span class="nt">-u</span>, <span class="nt">-U</span> NUM, <span class="nt">--unified</span><span class="o">[=</span>NUM]
              output NUM <span class="o">(</span>default 3<span class="o">)</span> lines of unified context
</code></pre></div></div>

<p>A quick reference to the <code class="language-plaintext highlighter-rouge">man</code> page of GNU <code class="language-plaintext highlighter-rouge">diff</code> indicates that the unified format comes with an optional argument which denotes the size of the associated context, in terms of number of lines. This is a perfectly reasonable functionality to include into our tool as well. Let’s define a record with optional fields to allow as to format our diff accordingly.</p>

<pre><code class="language-roc">DiffParameters : { colorize ? Bool, contextSize ? U64 }
</code></pre>

<p>Now, we are ready pass this as the first argument of our <code class="language-plaintext highlighter-rouge">diffFormat</code> and <code class="language-plaintext highlighter-rouge">formatDiff</code> functions. For convenience, we’ll refactor the latter into a primary function and its auxiliary counterpart, <code class="language-plaintext highlighter-rouge">formatDiffHelp</code>:</p>
<pre><code class="language-roc">diffFormat : DiffParameters, List Str, List Str -&gt; List Str
diffFormat = \params, x, y -&gt;
    formatDiff params (diff x y)

formatDiff : DiffParameters, Diff -&gt; List Str
formatDiff = \params, input -&gt;
    formatDiffHelp params input

formatDiffHelp : DiffParameters, Diff -&gt; List Str
formatDiffHelp = \{ colorize ? Bool.false, contextSize ? 3 }, diffResult -&gt;
    List.map diffResult \elem -&gt;
        (_, source) = unpackLine elem.source
        (_, target) = unpackLine elem.target

        when elem.op is
            Match -&gt;
                "  $(source)"

            Insertion -&gt;
                diffLine = "+ $(target)"
                if colorize then
                    colorizeText GreenFg diffLine
                else
                    diffLine

            Deletion -&gt;
                diffLine = "- $(source)"
                if colorize then
                    colorizeText RedFg diffLine
                else
                    diffLine
</code></pre>

<p>We weave our parameters record through the chain of calls, which are responsible for formatting the diff, and utilize the parameter values as needed. We’ve made use of the <code class="language-plaintext highlighter-rouge">colorize</code> parameter and, thus, enable the user to opt in to a colorized diff representation. We can now proceed to filtering only the lines which correspond to insertion and deletion operations, and all lines up to <code class="language-plaintext highlighter-rouge">contextSize</code> on either side. This means that we’re going to only show as many as <code class="language-plaintext highlighter-rouge">2 * contextSize</code> matching lines, between any two non-empty, contiguous segments, consisting of zero or more insertion operations, and zero or more deletion ones.</p>

<pre><code class="language-roc">filterDiff : Diff, U64 -&gt; Diff
filterDiff = \diffResult, contextSize -&gt;
    ranges = filterDiffHelp diffResult contextSize
    List.walk ranges [] \updated, (first, last) -&gt;
        List.concat updated (slice diffResult first last)

filterDiffHelp : Diff, U64 -&gt; List Range
filterDiffHelp = \diffResult, contextSize -&gt;
    when List.len diffResult is
        0 -&gt; []
        n -&gt;
            allMatching = List.all diffResult \elem -&gt; elem.op == Match
            if allMatching then
                []
            else
                lastDiffEntryIdx = n - 1
                (subseqRanges, _) = List.walkWithIndex diffResult ([], 0) \(ranges, latestSeqStart), elem, idx -&gt;
                    prev : Result DiffOp [NoDiffOpBeforeSeqStart]
                    prev =
                        when idx is
                            0 -&gt; Err NoDiffOpBeforeSeqStart
                            _ -&gt;
                                when List.get diffResult (idx - 1) is
                                    Err OutOfBounds -&gt; crash "Error: Unexpected out-of-bounds access in diff list"
                                    Ok prevDiffLine -&gt; Ok prevDiffLine.op

                    when idx is
                        0 -&gt;
                            when prev is
                                Err NoDiffOpBeforeSeqStart -&gt;
                                    (
                                        ranges,
                                        idx,
                                    )

                                _ -&gt;
                                    crash "TODO: Prev cannot be a match/insertion/deletion if curr idx is 0"

                        _ -&gt;
                            when prev is
                                Ok Match -&gt;
                                    when elem.op is
                                        Match -&gt;
                                            if idx == lastDiffEntryIdx then
                                                (
                                                    List.concat ranges (maybeTrimRange (latestSeqStart, idx) idx contextSize),
                                                    latestSeqStart,
                                                )
                                            else
                                                (
                                                    ranges,
                                                    latestSeqStart,
                                                )

                                        _ -&gt;
                                            prevRange = (latestSeqStart, idx - 1)
                                            matchingRange = maybeTrimRange prevRange idx contextSize
                                            rangesUpdated = List.concat ranges matchingRange

                                            if idx == lastDiffEntryIdx then
                                                (
                                                    List.append rangesUpdated (idx, idx),
                                                    idx,
                                                )
                                            else
                                                (
                                                    rangesUpdated,
                                                    idx,
                                                )

                                Ok Insertion | Ok Deletion -&gt;
                                    when elem.op is
                                        Match -&gt;
                                            prevRange = (latestSeqStart, idx - 1)
                                            rangesUpdated = List.append ranges prevRange
                                            if idx == lastDiffEntryIdx then
                                                (
                                                    List.concat rangesUpdated (maybeTrimRange (idx, idx) idx contextSize),
                                                    idx,
                                                )
                                            else
                                                (
                                                    rangesUpdated,
                                                    idx,
                                                )

                                        _ -&gt;
                                            if idx == lastDiffEntryIdx then
                                                (
                                                    List.append ranges (latestSeqStart, idx),
                                                    idx,
                                                )
                                            else
                                                (
                                                    ranges,
                                                    latestSeqStart,
                                                )

                                Err NoDiffOpBeforeSeqStart -&gt;
                                    crash "TODO: Prev must be a match/insertion/deletion if curr idx is greater than 0"

                subseqRanges
</code></pre>

<p>We employ two auxiliary functions in <code class="language-plaintext highlighter-rouge">filterDiffHelp</code>, and they’re defined as follows:</p>
<pre><code class="language-roc">slice : List elem, U64, U64 -&gt; List elem
slice = \list, fromInclusive, untilInclusive -&gt;
    List.sublist list { start: fromInclusive, len: 1 + untilInclusive - fromInclusive }

maybeTrimRange : Range, U64, U64 -&gt; List Range
maybeTrimRange = \(first, last), lastIdx, maxLength -&gt;
    if first == 0 then
        if last == lastIdx then
            crash "TODO: Unexpected state, this should already have been returned as the sole range beforehand"
        else if last &gt;= maxLength then
            [(1 + last - maxLength, last)]
        else
            [(first, last)]
    else if last == lastIdx then
        if last - maxLength + 1 &lt;= first then
            [(first, last)]
        else
            [(first, first + maxLength - 1)]
    else if last - first + 1 &lt;= 2 * maxLength then
        [(first, last)]
    else
        [(first, first + maxLength - 1), (1 + last - maxLength, last)]
</code></pre>

<p>We proceed with utilizing the newly-implemented context-filtering functionality:</p>
<pre><code class="language-roc">formatDiffHelp = \{ colorize ? Bool.false, contextSize ? 3 }, diffResult -&gt;
    filterDiff diffResult contextSize
    |&gt; List.map \elem -&gt;
...
</code></pre>

<p>The resulting implementation is almost equivalent to GNU <code class="language-plaintext highlighter-rouge">diff</code>’s unified format, with the only difference that the absolute line numbers and diff block sizes aren’t displayed. The latter are actually referred to as <em>hunks</em>.</p>

<p>Let’s actually get to completing the implementation of our unified format output in the following section.</p>

<h2 id="section-n5-unified-format">Section N.5: Unified Format</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TODO: Code and narrative.
</code></pre></div></div>

<h2 id="section-n6-putting-it-all-together">Section N.6: Putting It All Together</h2>
<p>In order to be able to employ our diff functionality in the real world, we’ll need to promote it to an executable, which we’ll then run against arbitrary input files.
Let’s create a file called <code class="language-plaintext highlighter-rouge">main.roc</code> and import the exposed <code class="language-plaintext highlighter-rouge">diffFormat</code> function, which will do all the associated heavy-lifting.</p>

<pre><code class="language-roc">app "diff"
    packages {
        cli: "https://github.com/roc-lang/basic-cli/releases/download/0.9.1/y_Ww7a2_ZGjp0ZTt9Y_pNdSqqMRdMLzHMKfdN8LWidk.tar.br",
    }
    imports [
        cli.Stdout,
        cli.Stderr,
        cli.Arg,
        cli.Task.{ Task, await },
        cli.File,
        cli.Path,
        Lcs.{ diffFormat },
    ]
    provides [main] to cli
</code></pre>

<p>We’re going to base our diff tool on the <code class="language-plaintext highlighter-rouge">basic-cli</code> platform, which - as its name aptly suggests - provides all key ingredients that we need for our task. Correspondingly, we’re importing a few of its features, so that we can write text to standard output and standard error streams, as well as read command-line arguments and perform file reading operations.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ roc build main.roc --output rocdiff
0 errors and 0 warnings found in 522 ms
 while successfully building:

    rocdiff
</code></pre></div></div>

<p>Now that we have the freshly minted <code class="language-plaintext highlighter-rouge">rocdiff</code> executable in our local directory, it’s time for an actual test:</p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> ./rocdiff Hello.roc HelloWorld.roc
<span class="gd">- app "hello"
</span><span class="gi">+ app "hello-world"
</span>      packages { pf: "https://github.com/roc-lang/basic-cli/releases/download/0.9.1/y_Ww7a2_ZGjp0ZTt9Y_pNdSqqMRdMLzHMKfdN8LWidk.tar.br" }
      imports [pf.Stdout]
      provides [main] to pf

  main =
<span class="gd">-     Stdout.line "Hello!"
</span><span class="gi">+     Stdout.line "Hello, World!"
</span>
</code></pre></div></div>

<p>Nice! We’ve got the expected output.</p>

<p>Any external tool can be used as a <code class="language-plaintext highlighter-rouge">git diftool</code>, and so can our own <code class="language-plaintext highlighter-rouge">rocdiff</code>. You can run the following in any directory, associated with a <code class="language-plaintext highlighter-rouge">git</code> repository:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git difftool <span class="nt">--extcmd</span><span class="o">=</span>&lt;full_rocdiff_path&gt;

Viewing <span class="o">(</span>1/&lt;total_number_of_changed_files&gt;<span class="o">)</span>: <span class="s1">'&lt;changed_file_path&gt;'</span>
Launch <span class="s1">'&lt;path_to_rocdiff&gt;'</span> <span class="o">[</span>Y/n]?
</code></pre></div></div>

<p>Just as <code class="language-plaintext highlighter-rouge">git diff</code>, it’ll show all unstaged differences. Please, note that <code class="language-plaintext highlighter-rouge">git difftool</code>, regardless of what the external tool is, behaves slightly differently and asks for confirmation regarding launching the corresponding diff tool, with respect to each changed file.</p>

<p>If you don’t have any outstanding unstaged changes, you could, for instance, view the diff between any arbitrary two commits. For example, <code class="language-plaintext highlighter-rouge">HEAD~..HEAD</code> will show you the most recent commit:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git difftool <span class="nt">--extcmd</span><span class="o">=</span><span class="sb">`</span><span class="nb">realpath</span> ./rocdiff<span class="sb">`</span> HEAD~..HEAD
</code></pre></div></div>

<p>The above will only utilize our diff tool on a one-off basis. If we want this to apply to an entire repository, we could add the following to the <code class="language-plaintext highlighter-rouge">.git/config</code> file of the repository in question:</p>
<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[diff]</span>
    <span class="py">tool</span> <span class="p">=</span> <span class="s">rocdiff</span>

<span class="nn">[difftool "rocdiff"]</span>
    <span class="py">cmd</span> <span class="p">=</span> <span class="s">&lt;full_rocdiff_path&gt; "$LOCAL" "$REMOTE"</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">[difftool "rocdiff"]</code> section defines our <code class="language-plaintext highlighter-rouge">rocdiff</code> tool within the context of <code class="language-plaintext highlighter-rouge">git difftool</code> so that our tool may be referenced from within that context. The <code class="language-plaintext highlighter-rouge">[diff]</code> section sets the actual <code class="language-plaintext highlighter-rouge">git difftool</code> to <code class="language-plaintext highlighter-rouge">rocdiff</code>, based on said definition. Please, ensure that you replace <code class="language-plaintext highlighter-rouge">&lt;full_rocdiff_path&gt;</code> with the actual full absolute path to the <code class="language-plaintext highlighter-rouge">rocdiff</code> executable on your local machine.</p>

<p>Further, note that, if you’ve already got an existing <code class="language-plaintext highlighter-rouge">tool</code> set in the <code class="language-plaintext highlighter-rouge">[diff]</code> section, you’ll have to either remove the existing section, comment it out, or just add the new <code class="language-plaintext highlighter-rouge">[diff]</code> section, containing <code class="language-plaintext highlighter-rouge">tool = rocdiff</code>, after all other pre-existing <code class="language-plaintext highlighter-rouge">[diff]</code> sections. This is necessary, because <code class="language-plaintext highlighter-rouge">git difftool</code> will only take only the last one into account.</p>

<p>Please, note that any supported <code class="language-plaintext highlighter-rouge">rocdiff</code> command-line arguments may be specified as well.</p>

<p>Alternatively, the above could be set from the command line, with respect to the local repository, assuming we’ve already navigated to it:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config diff.tool rocdiff
git config difftool.rocdiff.cmd "&lt;full_rocdiff_path&gt; \$LOCAL \$REMOTE"
</code></pre></div></div>

<p>Adding the <code class="language-plaintext highlighter-rouge">--global</code> flag after <code class="language-plaintext highlighter-rouge">git config</code> applies the equivalent changes globally and, this way, the configured <code class="language-plaintext highlighter-rouge">difftool</code> can be utilized in any <code class="language-plaintext highlighter-rouge">git</code> repository on the same host, and the same user, with respect to which the <code class="language-plaintext highlighter-rouge">git config</code> operation applies; i.e., this is the user whose <code class="language-plaintext highlighter-rouge">${HOME}/.gitconfig</code> gets edited as a result. Just as in the local repository case discussed above, equivalent edits to the global (with respect to a given user) <code class="language-plaintext highlighter-rouge">.gitconfig</code> file are going to result in the same behaviour, as the resulting behaviour from <code class="language-plaintext highlighter-rouge">git config --global</code>.</p>

<p>Now, regardless of whether we’ve opted to modify the local or global <code class="language-plaintext highlighter-rouge">git</code> config, our default <code class="language-plaintext highlighter-rouge">difftool</code> is set to <code class="language-plaintext highlighter-rouge">rocdiff</code> and can be invoked directly as follows:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git difftool
</code></pre></div></div>

<p>Just as above - and as in the case of <code class="language-plaintext highlighter-rouge">git diff</code> itself - an arbitrary diff range could be specified. In case there are no unstaged changes in the current <code class="language-plaintext highlighter-rouge">git</code> repository, the most recent commit, if one exists, could be shown as follows:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git difftool HEAD~..HEAD
</code></pre></div></div>

<p>If at any point, you’d like to switch back to your previous configuration, you can just delete or comment out the <code class="language-plaintext highlighter-rouge">rocdiff</code> section which sets <code class="language-plaintext highlighter-rouge">tool = rocdiff</code> from your <code class="language-plaintext highlighter-rouge">git</code> config, as necessary:</p>
<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#[diff]
#    tool = rocdiff
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">[difftool "rocdiff"]</code> definition section does not have to be removed.</p>

<p>Please, note that <code class="language-plaintext highlighter-rouge">git difftool</code> and <code class="language-plaintext highlighter-rouge">git diff</code> are completely distinct operations.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TODO
Reference:
http://git-scm.com/docs/gitattributes#_defining_an_external_diff_driver
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TODO
GIT_EXTERNAL_DIFF=...
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TODO
$ cat .git/config
...
[diff "rocdiff"]
    command = &lt;full_rocdiff_path&gt; "$LOCAL" "$REMOTE"

$ cat .gitattributes
* diff=rocdiff

$ git diff --ext-diff
</code></pre></div></div>

<pre><code class="language-TODO">$ man git
...
       GIT_EXTERNAL_DIFF
           When the environment variable GIT_EXTERNAL_DIFF is set, the program named by it is called, instead of the diff invocation described above. For a path that is added, removed, or modified, GIT_EXTERNAL_DIFF is called with 7 parameters:

               path old-file old-hex old-mode new-file new-hex new-mode

           where:

       &lt;old|new&gt;-file
           are files GIT_EXTERNAL_DIFF can use to read the contents of &lt;old|new&gt;,

       &lt;old|new&gt;-hex
           are the 40-hexdigit SHA-1 hashes,

       &lt;old|new&gt;-mode
           are the octal representation of the file modes.

           The file parameters can point at the user’s working file (e.g.  new-file in "git-diff-files"), /dev/null (e.g.  old-file when a new file is added), or a temporary file (e.g.  old-file in the index).  GIT_EXTERNAL_DIFF should not worry about unlinking the temporary file --- it is removed when
           GIT_EXTERNAL_DIFF exits.

           For a path that is unmerged, GIT_EXTERNAL_DIFF is called with 1 parameter, &lt;path&gt;.

           For each path GIT_EXTERNAL_DIFF is called, two environment variables, GIT_DIFF_PATH_COUNTER and GIT_DIFF_PATH_TOTAL are set.
...


$ man git-config
...
       diff.external
           If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the ‘GIT_EXTERNAL_DIFF’ environment variable. The command is called with parameters as described under "git Diffs" in git(1). Note: if you want to
           use an external diff program only on a subset of your files, you might want to use gitattributes(5) instead.

...
</code></pre>

<pre><code class="language-TODO">$ git diff
['diff/index.md', '/tmp/git-blob-pOomA2/index.md', '74124a8f9bb1da280a7b7ba2e3080ed76e04993f', '100644', 'diff/index.md', '0000000000000000000000000000000000000000', '100644']
['diff/src/Lcs.roc', '/tmp/git-blob-DcMCZi/Lcs.roc', 'e2fc3001a10a1390c1cbab7f69d7a699b1117633', '100644', 'diff/src/Lcs.roc', '0000000000000000000000000000000000000000', '100644']
</code></pre>

<h2 id="section-n7-summary">Section N.7: Summary</h2>

<p><a href="#figure-n-m-summary">Figure N.M</a> summarizes the key ideas introduced in this chapter.</p>

<p align="center">
<a id="figure-n-m-summary"><img src="" alt="TODO: Add image." /></a><br />
Figure N.M: A diff tool concept map.
</p>

<h2 id="section-n8-exercises">Section N.8: Exercises</h2>

<h3 id="color-themes">Color Themes</h3>

<p>Produce colorized output in correspondence to different pre-set themes, with the theme name of choice specified as an optional command-line argument, and assuming a default value otherwise.</p>

<h3 id="diff-formats">Diff Formats</h3>
<p>Output other diff formats, such as the context format, normal format, <code class="language-plaintext highlighter-rouge">ed</code> format, RCS format, side-by-side format, line-group format and if-then-else format. Just as the behaviour of the GNU <code class="language-plaintext highlighter-rouge">diff</code> tool, the desired one could be specified as an optional command-line argument, assuming a default value otherwise.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/ANSI_escape_code#Colors. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </main>
    <footer>
  Copyright © the contributors 2024
  &middot;
  <a href="https://github.com/roc-lang/book-of-examples">GitHub repository</a>
</footer>

  </body>
</html>
